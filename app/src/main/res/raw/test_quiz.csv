Which of the following will run a modular program]java -cp modules mod/class,java -cp modules -m mod/class]java -cp modules -p mod/class]java -m modules mod/class]java -m modules -p mod/class]java -p modules -m mod/class]java -p modules -sp mod/class]6]Exam requires knowing how to run at the command line. The new -p option specifies the module path. The new -m option precedes the program to be run in the format moduleName/fullyQualifiedClassName. Option G is the only one that matches these requirements.
Suppose you have a module named com.vet. Where could you place the following module-info.java file to create a valid module? nnn public module com.vet { nnn exports com.vet; }]At the same level as the com folder]At the same level as the vet folder]Inside the vet folder]Root folder]C disc]None of the above]6]If this were a valid module-info.java file, it would need to be placed at the root directory of the module, which is option A. However, a module is not allowed to use the public access modifier. Option F is correct because the provided file does not compile regardless of placement in the project.
Which of the following are true to sort the list?nnn13: int multiplier = 1;nnn14: multiplier *= -1;nnn15: List<Integer> list = List.of(99, 66, 77, 88);nnn16: list.sort(________)]Line 14 must be removed for any of the following lambdas to compile.]Line 14 may remain for any of the following lambdas to compile.](x, y) -> multiplier * y.compareTo(x)]x, y -> multiplier * y.compareTo(x)](x, y) -> return multiplier * y.compareTo(x)]x, y -> return multiplier * y.compareTo(x)]1]This is a great example to practice the process of elimination. The first thing to notice is that multiplier is not effectively final since it is reassigned. None of the lambdas will compile, making option A correct. The next step is to look at the lambda syntax. Options D  and F are invalid because lambdas with more than one parameter must have parentheses. Options E and F are invalid because a return statement may not be used in a lambda without a block present. While option C at least compiles, the code fails at runtime because List.of() creates an immutable list. This is tricky as none of the lambdas will work successfully
Which of the following statements about error handling in Java are correct?]Checked exceptions are intended to be thrown by the JVM (and not the programmer).]Checked exceptions are required to be handled or declared]Errors are intended to be thrown by the JVM (and not the programmer)]Errors are required to be caught or declared]Runtime exceptions are intended to be thrown by the JVM (and not the programmer)]Runtime exceptions are required to be handled or declared]2]Only checked exceptions are required to be handled or declared, making option B correct and option F incorrect. An Error is intended to be thrown by the JVM and never caught by the programmer, making option C correct and options A, D, and E incorrect. While a programmer could throw or catch an Error, this would be a horrible practice.
Which of the following are valid instance members of a class?]var var = 3;]Var case = new Var();]void var() {}]int Var() { var _ = 7; return _;}]String new = "var";]var var() { return null; }]3]Option A is incorrect because var is only allowed as a type for local variables, not instance members. Options B and E are incorrect because new and case are reserved words and cannot be used as identifiers. Option C is correct, as var can be used as a method name. Option D is incorrect because a single underscore (_) cannot be used as an identifier starting with Java 9. Finally, option F is incorrect because var cannot be specified as the return type of a method.
